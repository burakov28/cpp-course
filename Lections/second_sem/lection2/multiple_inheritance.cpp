// John Lakos cppnow 2016

struct a {
	int x;
	virtual void f() = 0;
};
struct b : a
{

};
struct c : a
{
	
};
struct d : b, c
{
	
}; // d -> b -> a(1); d -> c -> a(2) у нас фактически два разных "а". a& aa = dd error так как не понятно по какому пути кастить. правильнно: a& aa = (b&)dd;
// все virtual склеиваются, остальные создают разные subobject
// для обращения к какому-нибудь x надо писать dd.b::x
// если мы реализуем виртуальную функцию только в одном из путей, то если не виртуальное наследование, 
// у нас разные пути до разных а и у нас объявлена f только на одном пути и получается хуйня
// по сути тут у нас две виртуальные функции, а при виртуальном наследовании только одна и мы ее уже заоверрайдили

struct bb : virtual a
{
	
};
struct cc : virtual a
{
	
};
struct dd : bb, cc
{
	
}; // d -> b -> a; d -> c -> a у нас только один "а". 
// если оверрайд только в b то ок, так как этот класс перестает быть абстрактным. если только в b и в c только multiple overriding
// 
int main() {
	d d_;
	d_.x;
}