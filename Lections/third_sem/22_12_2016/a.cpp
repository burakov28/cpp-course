Запись в память происходит не так что процессор ждет пока произойдет запись, все кладется в store_buffer - очередь на запись в память
Разработчики железа пытаются создать иллюзию программистам так, что кэшей нет, а память вообще одна. То есть если переменную записали в память, другой процесс
получит то же значение, которое записали.


!!Memory model
Что значит создать такую иллюзию:
Представим //std::atomic<bool> flag1,flag2;

поток1
flag1 = true;
if (flag2)
	retry();
else
	work();

поток2
flag2 = true;
if (flag1)
	retry();
else
	work();

n-ый флаг значит что n-ый поток работает
В данном случае не может flag1 = true выполнятся перед if(flag2)

Sequential consistency -- выполнение операций в порядке
x86 заставляет все инструкции выполняться подряд. too strict?

Power, ARMv7 не особо анфорсит это, инстуркции могут выполняться не последовательно.
Возможно подход x86 плох для одноядерных (?) систем.

В Power и ARMv7 есть инструкция (пусть memory_barier) которые говорят "Выполни все лоады и сторы до этой строки прямо сейчас, а все что после этой строки выполни потом".
Обычно эта функция дорогая. 
То есть поддерживать иллюзию одной памяти дорого. 
too strict: плох для однопоточного но хорош для atomic операций
relaxed: хорош для однопоточной программы, но очень плох для атомарных операций

рассмотрим снова:

поток1
x = 5; // <-- новая операция
flag1 = true;
memory_barrier(); //<-- эта операция не может понять как важен flag1 и x и поэтому иногда memory_barrier не всегда так необходим
if (flag2)
	retry();
else
	work();

поток2
flag2 = true;
if (flag1)
	retry();
else
	work();


рассмотрим
void f()
{
	x = 1;
	m.lock();
	y = 2;
	m.unlock();
	z = 3;
}
В этом коде главное не вытаскивать y из мьютекса. И в теории x тоже не должны запихивать в мьютекс.
А z можем выполнить и до анлока. Задача была можно ли переупорядочить запись в переменные.

// кстати состояние гонки это UB

А что если запихнуть x после анлока. Какой-то пример:

void g()
{
	m.lock();
	int g_copy = y;
	m.unlick();
	if (y == 2) // предположим y == 2 - значит что функция выполнила свою работу. А если мы запихнем x после анлока то это будет значить, что работа выполнена, хотя это не будет правдой
		function(x); 
}

Тоже самое про z нельзя перенести до лока. Таким образом нельзя переносить операцию через lock+unlock. x = 1 -- работа. То есть x и z это такие как бы инварианты.
Это все вообще к тому, что не всегда нужно too strict правила, они нужны иногда, но не всегда
Между функциями компилятор никакие лоады сторы не переупорядочивает
Еще нельзя переупорядочивать unlock и lock местами, может возникнуть дедлок.
Т.о. три пункта когда нельзя переупорядочивать операции.

memory_order_seq_cst(default )
memory_order_relaxed

relaxed -- никаких ограничений на порядок. То есть операция атомарная, но порядок по отношению к другим не важен
Пример:
	std::thread th(work);
	th.join();
	counter.load(memory_order_relaxed);
	void work() {
		for(;;)
			if(...)
				counter.fetch_add(1, memory_order_relaxed);
	}
acquire
release
acquire_release

std::atomic<int> counter;
void work()
{
	counter.fetch_add(1, memory_order_relaxed);
}

Все записи в память это "Выполни когда-ниубдь"
А с мемори ордером "Выполни когда-нибудь но в таком-то порядке"

Пример чего-то. Если с seq_cnst то это слишком много. Можно ослабить
Поток чтения данных
if (ready.load(acqurie))
{
	data.load(relaxed);
	//...
}

Поток записи данных
data.store(42, relaxed);
ready.store(true, release);

Все после acquire в одном потоке будут видеть все операции в другом потоке перед release

ни одна мемори-операция не должна обгонять acquire и ни одна операция не должна идти раньше release.

Пример когда acquire-release лучше чем seq_cst:

1
x.store(1);

2
y.store(1);

3
int xx = x.load();
int yy = y.load();
if (x == 1 && yy == 0)
	printf("x before y");

4
int yy = y.load();
int xx = x.load();
if (yy == 1 && x == 0)
	printf("y before x");

Невозможно чтобы оба распечатали свое.




























