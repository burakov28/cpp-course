Undefined behaviour

void sum(float* result, float const* arr, size_t n)
{
	for (size_t i = 0; i < n; ++i)
		*result += arr[i];
}

Это херовый код, так как мы каждую итерацию считываем и записываем по памяти. Но компилятор не может оптимизировать, создав локальную переменную и записывая в нее
Он не имеет права, так как если result указывает на элемент arr, получится не то, что хотелось. 
result и arr в данном случае говорится alias-ится. И компилятор не может считать, что одно не алиасится к другому.

Другой пример.
void memcpy(char* dst, char const*src, size_t n)
{
	for (size_t i = 0; i != n; ++i)
		*dst++=*src++;
}

dst и src не могут перекрывать друг друга

offtop: компилятор фортрана может предположить что они не алиасятся. И тогда это работает сильно быстрее. Поэтому на суперкомпьютерах используется фортран для 
вычисления на фортране

В c (но в c++ это тоже поддерживается) есть ключевое слово restrict, которое говорит что указатель не алиасится ни с каким другим указателем.
Теперь компилятор может копировать пачками (restrict)

a = __assume_aligned(a, 16);
Функция говорит предполагать что указатель выравнен по 16 байт. Есть шанс векторизации

Примеры UF: double delete, разыменовывание удаленного указателя, каст числа к указателю и обратно
В библиотеке: lower_bound от несортированного массива.
UF в любом языке -- в функции вычисления хэша менять элемент (кек).

Задача: сколько флотов больше 0
int* result;
float* arr;

for (size_t i = 0; i != n; i++) 
{
	if (arr[i] > 0.f)
		++ *result;
}

Обычно изменение инта не может изменить что-либо в арр. Но такое может быть и поэтому это нельзя векторизовать.
//Векторизовать - операции по чанкам.

strict aliasing rule -- никогда не обращаемся к ячейке float как double. То есть если записали одно то и обращаемся к тому же.
gcc спокойно переупорядочивает операции с разными типами, так как там используется это правило. В других компиляторах не всегда так.
Пример:
int* a;
float* b;
*a = 5;
??? = *b;
Если бы a и b указывали на одну память, то их нельзя переупорядочивать. А gcc будет.

Еще один пример:
struct vector
{
	float* a;
	size_t n;
};
for (size_t i = 0; i != v.n; i++)
	v.a[i] = 0;
v.n будет пересчитываться на каждой итерации. Потому что могут алиаситься. (Не у gcc). 
По стандарту char может алиаситься с чем угодно, с ним нельзя юзать правило.

a + 1 > a -- всегда правда. Переполнение знаковых -- UF. Это правило могли бы удалить, но не удаляют потому что компиляторы используют это для оптимизаций

Еще пример (из ядра Линукса, на C):
void f(mytype* ptr)
{
	int unused = ptr->data;
	if (!ptr) -- здесь проверка всегда неправда, так как раньше уже было разыменовывание указателя ptr. Кек.
		return;
	int i, v;
	for (i = 0, v = arr[i]; i!= 10; v = arr[++i])
	{

	}
}

Это то же, что
i = v;
for (;;)
{
	v = arr[i];
	if (i == 10) Это условие никогда не выполнится, так как i не может быть равно 10 так как массив размера 10 и i может лежать от 0 до 9.
		break;
	++i;
}



































