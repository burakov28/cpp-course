Memory allocation

Страничная адресация, у программы виртуальная память, которая ссылается на физическую с помощью страничной адресации. К физической не обратиться из программы
(кроме ядра). Программе кажется что она одна работает, то есть не видит память других программ.

Ядро ОС это такая программа которая запускается самой первой и работает все время, она смотрит чтобы программы работали только со своей памятью. Состоит из менеджера
памяти, планировщиков (чтобы создавать иллюзию многопоточности, по таймеру переключает выполнение программ), драйверов устройств, может даже файловых систем. 
В основном ядро состоит как раз из драйверов.

Функции ядра в приближении: mmap, munmap (OSIX). В windows VirtuallAlloc и VirtualFree.

сигнатуры:
void* malloc(size_t);
void* mmap(void* location, size_t size, ...);
Говорит "хочу такой отрезок страниц от location до location + size" в виртуальной памяти. Это видимо то как программа просит ядро о памяти, поэтому и виртуальная,
а не физическая. В качестве location можно указать нулевой указатель, чтобы ядро само искало свобдное место. Это функции ядра, интерфейс ядра.

int munmap(void* location, size_t size);
если ОК то 0, если ошибка -1 и в error_no номер ошибки. Часто ошибка -- size == 0

Если на каждый malloc вызывать mmap то будет выделяться страница размером в 4kb а обычно нам не так много надо и будет перерасход памяти.

mmap munmap по времени: no access	access(записать в страницу 1 байт)
1M парных запросов 		1.17с		2.64
1M по 1000 страниц 		1.12c		14*100 
									flag populate -- 10*100

flag populate -- найди мне память не лениво, а сразу

Выделение памяти выполняется лениво

В профайлере можно увидеть что 20% времени тратится на clear-page, на зануление страницы.

обычно malloc free не обращается к ядру, обращается только когда ему не хватает памяти, что редко.

Как реализован malloc.
Есть несколько реализаций mallocов для разных размеров. Размер запроса подгоняется под реализацию. В каждой реализации храним связный список указателей на свободное место.
Выровним блоки по какому-то адресу, а в начале этого блока укажем служебную информацию (размер ячеек). Если надо free(x) то без этого не понять, какого размера ячейка x
а так все ясно и понятно. Указатель на следующую свободную ячейку лежит в ячейке если она не нужна программе, а если нужна, то и указатель там не надо хранить.
При аллокации приоритет выдается наиболее заполненным блокам, чтобы освобождать блоки чаще. Иногда блоки не сразу освобождают, чтобы не гонять память туда сюда.

Все выше было для малых объектов (меньше страницы).

С большими: используем два каких-то дерева: по адресам и по размерам. Когда выделяешь по размерам, когда удаляем -- по адресам.


Оптимизации: small object optimization и copy-on-write optimization

small obj opt: Строки обычно короткие. Будем так хранить 24 байта:
Первые 8 байт на size, а дальше либо строка, если она помещается, либо указатель на нее (который может указывать на больший блок) вместе с capacity. Таким образом 
храним строки на стеке и не используем malloc free, которые медленные.
Пример: либо храним указатель int* либо int, и второй вариант не использует malloc.

copy-on-write optimization: если копируем объект, то можно ссылаться на копируемый объект, а если скопировавшийся объект меняется, то создаем реальную копию.











































