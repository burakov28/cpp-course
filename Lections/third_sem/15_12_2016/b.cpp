recursive mutex позволяет лочить рекурсивно внутри одного потока.
Что решит проблему с предыдущим примером, когда с a на a.

Низкоуровневовые примитивы для потоков

Есть какой-то класс std::atomic<int> a; -- класс атомарных операций с интом

Если в одном потоке данные читаются, а в другом читаются и пишутся, то надо использовать мьютексы или атомики (атомики не стоит использовать все-таки)
int b = a.load();
a.store(42);
поддерживает операции + - загрузить итд. И все атомарно.
Внутри реализован как структура с интом и необходимыми инвариантами

void transaction(size_t from, size_t to, int amount) {
	int val = accounts[from].fetch_sub(amount);
	if (val < 0) {
		accounts[from].fetch_add(amount);
		throw insuff();
	}
	accounts[to].fetch_add(amount);
}
Теперь у нас проблема что счет иногда быть меньше нуля на одну операцию.

Попробуем реализовать мьютекс на атомиках

a.exchange(100); запиши это значение и верни старое (не точно)

struct mutex 
{
	mutex() : locked(false)
	{}
	void lock()
	{
		while (locked.exchange(true)); // busy-wait -- очень плохо. грузит шину
	}
	void unlock() {
		locked.store(false);
	}
	std::atomic<bool> locked;
} такой мьютекс типа spin-lock
Можно также усыпить поток в локе, а в анлоке его пробуждать.
Можно busy-wait делать реже, чтобы не нагружать так ядро (?)

В системах с большим количеством ядер доступ к памяти и поддержка ее инвариантов становится дороже

Представим программу:
есть atomic<int>
принимает число, создает столько потоков и пока не флаг, она прибавляет к этому инту единицу.
Пример, когда скейлится не линейно от кол-ва потоков.

N   iter
1	150M
2	27M
3	29M
4	29M

Это происходит потому что память шарится между ядрами, для этого надо записывать в L3, в однопоточном режиме все записывается в L1

false_shared -- какая-то хрень, я не понял. Я был голодным





